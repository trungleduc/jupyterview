{"version":3,"file":"4884.111b47d.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport const DRIVE_SEPARATOR = ':';\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n            stream.file = undefined;\n        }\n    }\n    read(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        const size = Math.min(((_a = stream.file.data.length) !== null && _a !== void 0 ? _a : 0) - position, length);\n        try {\n            buffer.set(stream.file.data.subarray(position, position + size), offset);\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a, _b;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        try {\n            if (position + length > ((_b = (_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) !== null && _b !== void 0 ? _b : 0)) {\n                const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n                stream.file.data = new Uint8Array(position + length);\n                stream.file.data.set(oldData);\n            }\n            stream.file.data.set(buffer.subarray(offset, offset + length), position);\n            return length;\n        }\n        catch (e) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        }\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EINVAL']);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    getattr(node) {\n        return {\n            ...this.fs.API.getattr(this.fs.realPath(node)),\n            mode: node.mode,\n            ino: node.id,\n        };\n    }\n    setattr(node, attr) {\n        // TODO\n    }\n    lookup(parent, name) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n        }\n        return this.fs.createNode(parent, name, result.mode);\n    }\n    mknod(parent, name, mode, dev) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(parent, name, mode, dev);\n    }\n    rename(oldNode, newDir, newName) {\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDir), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    readdir(node) {\n        return this.fs.API.readdir(this.fs.realPath(node));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        this._baseUrl = baseUrl;\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return Number.parseInt(this.request({ method: 'getmode', path: this.normalizePath(path) }));\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({ method: 'get', path: this.normalizePath(path) });\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Turn datetimes into proper objects\n        stats.atime = new Date(stats.atime);\n        stats.mtime = new Date(stats.mtime);\n        stats.ctime = new Date(stats.ctime);\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = new ContentsAPI(options.baseUrl, options.driveName, options.mountpoint, this.FS, this.ERRNO_CODES);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n","import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                size: 0,\n                ...model,\n                content: null,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        let item = await this.get(path);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            if (ext === '.ipynb') {\n                const contentUnescaped = this.unescapeContent(options.content);\n                const size = contentUnescaped.length;\n                item = {\n                    ...item,\n                    content: JSON.parse(contentUnescaped),\n                    format: 'json',\n                    type: 'notebook',\n                    size: size,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                const contentUnescaped = this.unescapeContent(options.content);\n                const size = contentUnescaped.length;\n                item = {\n                    ...item,\n                    content: JSON.parse(contentUnescaped),\n                    format: 'json',\n                    type: 'file',\n                    size: size,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                const contentUnescaped = this.unescapeContent(options.content);\n                const size = contentUnescaped.length;\n                item = {\n                    ...item,\n                    content: contentUnescaped,\n                    format: 'text',\n                    type: 'file',\n                    size: size,\n                };\n            }\n            else {\n                item = {\n                    ...item,\n                    size: atob(options.content).length,\n                };\n            }\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    unescapeContent(content) {\n        return decodeURIComponent(escape(atob(content)));\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            size: 0,\n            content: '',\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: JSON.parse(contentText),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                        size: contentText.length,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: contentText,\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                        size: contentText.length,\n                    };\n                }\n                else {\n                    const contentBytes = await response.arrayBuffer();\n                    const contentBuffer = new Uint8Array(contentBytes);\n                    model = {\n                        ...model,\n                        content: btoa(contentBuffer.reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                        size: contentBuffer.length,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, PathExt } from '@jupyterlab/coreutils';\nimport { Contents, DIR_MODE, FILE_MODE, IContents, } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { IServiceWorkerRegistrationWrapper, ServiceWorkerRegistrationWrapper, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\nimport localforage from 'localforage';\nconst BLOCK_SIZE = 4096;\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerRegistrationWrapper,\n    activate: (app) => {\n        return new ServiceWorkerRegistrationWrapper();\n    },\n};\n/**\n * A plugin handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    activate: (app) => {\n        // Setup communication with service worker for the virtual fs\n        const broadcast = new BroadcastChannel('/api/drive.v1');\n        let subitems;\n        broadcast.onmessage = async (event) => {\n            const request = event.data;\n            const contentManager = app.serviceManager.contents;\n            const path = request.path;\n            let model;\n            switch (request.method) {\n                case 'readdir': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory' && model.content) {\n                        subitems = model.content.map((subcontent) => subcontent.name);\n                        broadcast.postMessage(subitems);\n                    }\n                    else {\n                        broadcast.postMessage([]);\n                    }\n                    break;\n                }\n                case 'rmdir': {\n                    await contentManager.delete(path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'rename': {\n                    await contentManager.rename(path, request.data.newPath);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getmode': {\n                    model = await contentManager.get(path);\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(DIR_MODE);\n                    }\n                    else {\n                        broadcast.postMessage(FILE_MODE);\n                    }\n                    break;\n                }\n                case 'lookup': {\n                    try {\n                        model = await contentManager.get(path);\n                        broadcast.postMessage({\n                            ok: true,\n                            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        });\n                    }\n                    catch (e) {\n                        broadcast.postMessage({\n                            ok: false,\n                        });\n                    }\n                    break;\n                }\n                case 'mknod': {\n                    const mode = Number.parseInt(request.data.mode);\n                    model = await contentManager.newUntitled({\n                        path: PathExt.dirname(path),\n                        type: mode === DIR_MODE ? 'directory' : 'file',\n                        ext: PathExt.extname(path),\n                    });\n                    await contentManager.rename(model.path, path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getattr': {\n                    model = await contentManager.get(path);\n                    const size = model.size || 0;\n                    broadcast.postMessage({\n                        dev: 1,\n                        nlink: 1,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size,\n                        blksize: BLOCK_SIZE,\n                        blocks: Math.ceil(size / BLOCK_SIZE),\n                        atime: model.last_modified,\n                        mtime: model.last_modified,\n                        ctime: model.created,\n                        timestamp: 0,\n                    });\n                    break;\n                }\n                case 'get': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    let content = model.content;\n                    if (model.format === 'json') {\n                        content = JSON.stringify(model.content);\n                    }\n                    broadcast.postMessage({\n                        content,\n                        format: model.format,\n                    });\n                    break;\n                }\n                case 'put': {\n                    await contentManager.save(path, {\n                        content: request.data.format === 'json'\n                            ? JSON.parse(request.data.data)\n                            : request.data.data,\n                        type: 'file',\n                        format: request.data.format,\n                    });\n                    broadcast.postMessage(null);\n                    break;\n                }\n            }\n        };\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec !== null && spec !== void 0 ? spec : {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n"],"names":["DIR_MODE","FILE_MODE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","constructor","fs","this","open","stream","path","realPath","node","FS","isFile","mode","file","API","get","close","flags","parsedFlags","parseInt","needsWrite","put","undefined","read","buffer","offset","length","position","_a","size","Math","min","data","set","subarray","e","ErrnoError","ERRNO_CODES","write","_b","timestamp","Date","now","oldData","Uint8Array","llseek","whence","DriveFSEmscriptenNodeOps","getattr","ino","id","setattr","attr","lookup","parent","name","PATH","join2","result","ok","genericErrors","createNode","mknod","dev","rename","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","xhr","XMLHttpRequest","encodeURI","endpoint","send","JSON","stringify","console","error","status","parse","responseText","method","normalizePath","getmode","Number","newPath","dirlist","push","response","serializedContent","content","format","encode","binString","atob","len","i","charCodeAt","value","decode","binary","byteLength","String","fromCharCode","btoa","stats","atime","mtime","ctime","startsWith","slice","DriveFS","options","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","join","apply","IContents","Token","MIME","FILE","PLAIN_TEXT","OCTET_STREAM","TYPES","PageConfig","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","hasFormat","fileFormat","DEFAULT_STORAGE_NAME","Contents","reduceBytesToString","byte","_serverContents","Map","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","async","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","createInstance","description","storeName","_c","type","created","toISOString","dirname","PathExt","basename","extname","item","_incrementCounter","last_modified","mimetype","writable","counter","Private","EMPTY_NB","indexOf","key","setItem","toDir","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","serverContents","Array","from","_getServerDirectory","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","URLExt","newUntitled","contentUnescaped","unescapeContent","escape","slashed","toDelete","keys","filter","Promise","all","map","forgetPath","copies","Boolean","splice","normalizeCheckpoint","toString","checkpointID","includes","fileUrl","fetch","headers","match","contentText","text","contentBytes","arrayBuffer","contentBuffer","reduce","apiURL","json","err","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","localforagePlugin","autoStart","provides","ILocalForage","activate","app","localforageMemoryPlugin","requires","forage","ensureMemoryStorage","contentsPlugin","contents","started","initialize","catch","contentsRoutesPlugin","router","req","filename","res","listCheckpoints","Response","post","checkpoint","restoreCheckpoint","createCheckpoint","delete","deleteCheckpoint","query","nb","body","copyFrom","copy_from","copy","patch","save","serviceWorkerPlugin","IServiceWorkerRegistrationWrapper","ServiceWorkerRegistrationWrapper","emscriptenFileSystemPlugin","broadcast","BroadcastChannel","subitems","onmessage","event","contentManager","serviceManager","subcontent","postMessage","nlink","uid","gid","rdev","blksize","blocks","ceil","kernelsPlugin","IKernels","IKernelSpecs","kernelspecs","Kernels","kernelsRoutesPlugin","kernels","kernelId","restart","shutdown","kernelSpecPlugin","KernelSpecs","kernelSpecRoutesPlugin","specs","allKernelSpecs","allSpecs","forEach","spec","resources","default","licensesPlugin","ILicenses","Licenses","licensesRoutesPlugin","licenses","nbconvertRoutesPlugin","sessionsPlugin","ISessions","Sessions","sessionsRoutesPlugin","sessions","session","list","startNew","settingsPlugin","ISettings","settings","Settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale"],"sourceRoot":""}