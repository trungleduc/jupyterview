{"version":3,"file":"125.c5dd64a.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/session/lib/sessions.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token('@jupyterlite/session:ISessions');\n//# sourceMappingURL=tokens.js.map","import { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions {\n    /**\n     * Construct a new Sessions.\n     *\n     * @param options The instantiation options for a Sessions.\n     */\n    constructor(options) {\n        this._sessions = [];\n        this._pendingRestarts = new Set();\n        this._kernels = options.kernels;\n        // Listen for kernel removals\n        this._kernels.changed.connect((_, args) => {\n            var _a, _b;\n            switch (args.type) {\n                case 'remove': {\n                    const kernelId = (_a = args.oldValue) === null || _a === void 0 ? void 0 : _a.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    // find the session associated with the kernel\n                    const session = this._sessions.find((s) => { var _a; return ((_a = s.kernel) === null || _a === void 0 ? void 0 : _a.id) === kernelId; });\n                    if (!session) {\n                        return;\n                    }\n                    // Track the kernel ID for restart detection\n                    this._pendingRestarts.add(kernelId);\n                    setTimeout(async () => {\n                        // If after a short delay the kernel hasn't been re-added, it was terminated\n                        if (this._pendingRestarts.has(kernelId)) {\n                            this._pendingRestarts.delete(kernelId);\n                            await this.shutdown(session.id);\n                        }\n                    }, 100);\n                    break;\n                }\n                case 'add': {\n                    // If this was a restart, remove it from pending\n                    const kernelId = (_b = args.newValue) === null || _b === void 0 ? void 0 : _b.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    this._pendingRestarts.delete(kernelId);\n                    break;\n                }\n            }\n        });\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async get(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async list() {\n        return this._sessions;\n    }\n    /**\n     * Patch an existing session.\n     * This can be used to rename a session.\n     *\n     * - path updates session to track renamed paths\n     * - kernel.name starts a new kernel with a given kernelspec\n     *\n     * @param options The options to patch the session.\n     */\n    async patch(options) {\n        const { id, path, name, kernel } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path !== null && path !== void 0 ? path : session.path,\n            name: name !== null && name !== void 0 ? name : session.name,\n        };\n        if (kernel) {\n            // Kernel id takes precedence over name.\n            if (kernel.id) {\n                const session = this._sessions.find((session) => { var _a; return ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) === (kernel === null || kernel === void 0 ? void 0 : kernel.id); });\n                if (session) {\n                    patched.kernel = session.kernel;\n                }\n            }\n            else if (kernel.name) {\n                const newKernel = await this._kernels.startNew({\n                    id: UUID.uuid4(),\n                    name: kernel.name,\n                    location: PathExt.dirname(patched.path),\n                });\n                if (newKernel) {\n                    patched.kernel = newKernel;\n                }\n                // clean up the session on kernel shutdown\n                void this._handleKernelShutdown({\n                    kernelId: newKernel.id,\n                    sessionId: session.id,\n                });\n            }\n        }\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        var _a, _b, _c, _d;\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n        const id = (_c = options.id) !== null && _c !== void 0 ? _c : UUID.uuid4();\n        const nameOrPath = (_d = options.name) !== null && _d !== void 0 ? _d : options.path;\n        const dirname = PathExt.dirname(options.name) || PathExt.dirname(options.path);\n        const hasDrive = nameOrPath.includes(':');\n        const driveName = hasDrive ? nameOrPath.split(':')[0] : '';\n        // add drive name if missing (top level directory)\n        const location = dirname.includes(driveName) ? dirname : `${driveName}:${dirname}`;\n        const kernel = await this._kernels.startNew({\n            id,\n            name: kernelName,\n            location,\n        });\n        const session = {\n            id,\n            path,\n            name: name !== null && name !== void 0 ? name : path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        // clean up the session on kernel shutdown\n        void this._handleKernelShutdown({ kernelId: id, sessionId: session.id });\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        var _a;\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;\n        if (kernelId) {\n            await this._kernels.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n    /**\n     * Handle kernel shutdown\n     */\n    async _handleKernelShutdown({ kernelId, sessionId, }) {\n        // No need to handle kernel shutdown here anymore since we're using the changed signal\n    }\n}\n//# sourceMappingURL=sessions.js.map"],"names":["ISessions","Token","Sessions","constructor","options","this","_sessions","_pendingRestarts","Set","_kernels","kernels","changed","connect","_","args","_a","_b","type","kernelId","oldValue","id","session","find","s","kernel","add","setTimeout","async","has","delete","shutdown","newValue","get","Error","list","patch","path","name","index","findIndex","patched","newKernel","startNew","UUID","uuid4","location","PathExt","dirname","_handleKernelShutdown","sessionId","_c","_d","running","kernelName","nameOrPath","driveName","includes","split","push","ArrayExt","removeFirstOf"],"sourceRoot":""}