{"version":3,"file":"2349.7e33470.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/router.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/app.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/service-manager.js"],"sourcesContent":["/**\n * A simple router.\n */\nexport class Router {\n    constructor() {\n        this._routes = [];\n    }\n    /**\n     * Add a new GET route\n     *\n     * @param pattern The pattern to match\n     * @param callback The function to call on pattern match\n     *\n     */\n    get(pattern, callback) {\n        this._add('GET', pattern, callback);\n    }\n    /**\n     * Add a new PUT route\n     *\n     * @param pattern The pattern to match\n     * @param callback The function to call on pattern match\n     *\n     */\n    put(pattern, callback) {\n        this._add('PUT', pattern, callback);\n    }\n    /**\n     * Add a new POST route\n     *\n     * @param pattern The pattern to match\n     * @param callback The function to call on pattern match\n     *\n     */\n    post(pattern, callback) {\n        this._add('POST', pattern, callback);\n    }\n    /**\n     * Add a new PATCH route\n     *\n     * @param pattern The pattern to match\n     * @param callback The function to call on pattern match\n     *\n     */\n    patch(pattern, callback) {\n        this._add('PATCH', pattern, callback);\n    }\n    /**\n     * Add a new DELETE route\n     *\n     * @param pattern The pattern to match\n     * @param callback The function to call on pattern match\n     *\n     */\n    delete(pattern, callback) {\n        this._add('DELETE', pattern, callback);\n    }\n    /**\n     * Route a request.\n     *\n     * @param req The request to route.\n     */\n    async route(req) {\n        const url = new URL(req.url);\n        const { method } = req;\n        const { pathname } = url;\n        for (const r of this._routes) {\n            if (r.method !== method) {\n                continue;\n            }\n            const match = pathname.match(r.pattern);\n            if (!match) {\n                continue;\n            }\n            const matches = match.slice(1);\n            let body;\n            if (r.method === 'PATCH' || r.method === 'PUT' || r.method === 'POST') {\n                try {\n                    body = JSON.parse(await req.text());\n                }\n                catch {\n                    body = undefined;\n                }\n            }\n            return r.callback.call(null, {\n                pathname,\n                body,\n                query: Object.fromEntries(url.searchParams),\n            }, ...matches);\n        }\n        throw new Error('Cannot route ' + req.method + ' ' + req.url);\n    }\n    /**\n     * Add a new route.\n     *\n     * @param method The method\n     * @param pattern The pattern\n     * @param callback The callback\n     */\n    _add(method, pattern, callback) {\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(pattern);\n        }\n        this._routes.push({\n            method,\n            pattern,\n            callback,\n        });\n    }\n}\n//# sourceMappingURL=router.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ServerConnection, ServiceManager } from '@jupyterlab/services';\nimport { Application } from '@lumino/application';\nimport { Signal, Stream } from '@lumino/signaling';\nimport { WebSocket } from 'mock-socket';\nimport { Router } from './router';\n/**\n * A local event manager service.\n *\n * #### Notes\n * Schema IDs are not verified and all client-emitted events emit.\n */\nclass LocalEventManager {\n    constructor(options) {\n        this._isDisposed = false;\n        this._serverSettings = options.serverSettings;\n        this._stream = new Stream(this);\n    }\n    async emit({ data, schema_id }) {\n        this._stream.emit({ ...data, schema_id });\n    }\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this._stream.stop();\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get stream() {\n        return this._stream;\n    }\n    get serverSettings() {\n        return this._serverSettings;\n    }\n}\n/**\n * Server is the main application class. It is instantiated once and shared.\n */\nexport class JupyterLiteServer extends Application {\n    /**\n     * Construct a new JupyterLite object.\n     *\n     * @param options The instantiation options for a JupyterLiteServer application.\n     */\n    constructor(options) {\n        var _a;\n        super(options);\n        /**\n         * The name of the application.\n         */\n        this.name = 'JupyterLite Server';\n        /**\n         * A namespace/prefix plugins may use to denote their provenance.\n         */\n        this.namespace = this.name;\n        /**\n         * The version of the application.\n         */\n        this.version = 'unknown';\n        this._router = new Router();\n        const serverSettings = {\n            ...ServerConnection.makeSettings(),\n            WebSocket,\n            fetch: (_a = this.fetch.bind(this)) !== null && _a !== void 0 ? _a : undefined,\n        };\n        this._serviceManager = new ServiceManager({\n            standby: 'never',\n            serverSettings,\n            events: new LocalEventManager({ serverSettings }),\n        });\n    }\n    /**\n     * Get the underlying `Router` instance.\n     */\n    get router() {\n        return this._router;\n    }\n    /**\n     * Get the underlying lite service manager for this app.\n     */\n    get serviceManager() {\n        return this._serviceManager;\n    }\n    /**\n     * Handle an incoming request from the client.\n     *\n     * @param req The incoming request\n     * @param init The optional init request\n     */\n    async fetch(req, init) {\n        if (!(req instanceof Request)) {\n            throw Error('Request info is not a Request');\n        }\n        return this._router.route(req);\n    }\n    /**\n     * Attach the application shell to the DOM.\n     *\n     * @param id - The id of the host node for the shell, or `''`.\n     *\n     * #### Notes\n     * For this server application there is no shell to attach\n     */\n    attachShell(id) {\n        // no-op\n    }\n    /**\n     * A method invoked on a window `'resize'` event.\n     *\n     * #### Notes\n     * For this server application there is no shell to update\n     */\n    evtResize(event) {\n        // no-op\n    }\n    /**\n     * Register plugins from a plugin module.\n     *\n     * @param mod - The plugin module to register.\n     */\n    registerPluginModule(mod) {\n        let data = mod.default;\n        // Handle commonjs exports.\n        if (!Object.prototype.hasOwnProperty.call(mod, '__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach((item) => {\n            try {\n                this.registerPlugin(item);\n            }\n            catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    /**\n     * Register the plugins from multiple plugin modules.\n     *\n     * @param mods - The plugin modules to register.\n     */\n    registerPluginModules(mods) {\n        mods.forEach((mod) => {\n            this.registerPluginModule(mod);\n        });\n    }\n}\n//# sourceMappingURL=app.js.map","import { Token } from '@lumino/coreutils';\nimport SW_URL from './service-worker?text';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token('@jupyterlite/server-extension:IServiceWorkerManager');\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n//# sourceMappingURL=tokens.js.map","import { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { WORKER_NAME } from './tokens';\nconst VERSION = PageConfig.getOption('appVersion');\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\nexport class ServiceWorkerManager {\n    constructor(options) {\n        var _a;\n        this.unregisterOldServiceWorkers = async (scriptURL) => {\n            const versionKey = `${scriptURL}-version`;\n            // Check if we have an installed version. If we do, compare it to the current version\n            // and unregister all service workers if they are different.\n            const installedVersion = localStorage.getItem(versionKey);\n            if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {\n                // eslint-disable-next-line no-console\n                console.info('New version, unregistering existing service workers.');\n                const registrations = await navigator.serviceWorker.getRegistrations();\n                await Promise.all(registrations.map((registration) => registration.unregister()));\n                // eslint-disable-next-line no-console\n                console.info('All existing service workers have been unregistered.');\n            }\n            localStorage.setItem(versionKey, VERSION);\n        };\n        this._pingServiceWorker = async () => {\n            const response = await fetch(SW_PING_ENDPOINT);\n            const text = await response.text();\n            if (text === 'ok') {\n                setTimeout(this._pingServiceWorker, 20000);\n            }\n        };\n        this._registration = null;\n        this._registrationChanged = new Signal(this);\n        this._ready = new PromiseDelegate();\n        const workerUrl = (_a = options === null || options === void 0 ? void 0 : options.workerUrl) !== null && _a !== void 0 ? _a : URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        void this.initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    async initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this.unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n}\n//# sourceMappingURL=service-manager.js.map"],"names":["Router","constructor","this","_routes","get","pattern","callback","_add","put","post","patch","route","req","url","URL","method","pathname","r","match","matches","slice","body","JSON","parse","text","undefined","call","query","Object","fromEntries","searchParams","Error","RegExp","push","LocalEventManager","options","_isDisposed","_serverSettings","serverSettings","_stream","Stream","emit","data","schema_id","dispose","isDisposed","Signal","clearData","stop","stream","JupyterLiteServer","Application","_a","super","name","namespace","version","_router","ServerConnection","makeSettings","WebSocket","fetch","bind","_serviceManager","ServiceManager","standby","events","router","serviceManager","init","Request","attachShell","id","evtResize","event","registerPluginModule","mod","default","prototype","hasOwnProperty","Array","isArray","forEach","item","registerPlugin","error","console","registerPluginModules","mods","IServiceWorkerManager","Token","WORKER_NAME","split","VERSION","PageConfig","getOption","ServiceWorkerManager","unregisterOldServiceWorkers","async","scriptURL","versionKey","installedVersion","localStorage","getItem","info","registrations","navigator","serviceWorker","getRegistrations","Promise","all","map","registration","unregister","setItem","_pingServiceWorker","response","setTimeout","_registration","_registrationChanged","_ready","PromiseDelegate","workerUrl","URLExt","join","getBaseUrl","fullWorkerUrl","window","location","href","enableCache","set","initialize","catch","warn","registrationChanged","enabled","ready","promise","controller","getRegistration","register","err","_setRegistration","resolve","reject"],"sourceRoot":""}